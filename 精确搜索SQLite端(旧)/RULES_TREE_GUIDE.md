# 关系树功能完整指南

> **最后更新**: 2025-12-15

## 功能概述

语义森林规则树是一个强大的关键词管理和自动膨胀系统，允许你构建层级化的关键词组，实现智能搜索。

### 核心特性

1. **层级组织** - 支持无限层级的组嵌套
2. **关键词膨胀** - 搜索时自动展开组内所有关键词
3. **拖拽管理** - 可视化拖拽调整组的父子关系
4. **乐观锁并发** - 多人同时编辑时自动冲突检测和合并
5. **实时同步** - 基于 ETag 的增量更新机制

---

## 使用场景示例

### 场景1: 表情分类管理

```
😊 心情类
  ├─ 开心
  │   ├─ 哈哈
  │   ├─ 笑cry
  │   └─ 狗头
  ├─ 伤心
  │   ├─ 哭泣
  │   └─ 难过
  └─ 愤怒
      ├─ 生气
      └─ 抓狂
```

**效果**: 搜索"开心"时，自动匹配所有标记为"哈哈"、"笑cry"、"狗头"的图片

### 场景2: 角色 IP 管理

```
🎮 游戏角色
  ├─ 原神
  │   ├─ 派蒙
  │   ├─ 可莉
  │   └─ 纳西妲
  └─ 明日方舟
      ├─ 阿米娅
      └─ 凯尔希
```

**效果**: 搜索"原神"时，自动匹配所有相关角色的表情包

---

## 前端核心功能

### 1. 数据初始化流程

```javascript
MemeApp.init()
  → loadRulesTree()          // 从后端加载规则数据
     → buildTree(data)        // 将扁平结构组装成嵌套树
     → renderRulesTree()      // 渲染UI
  → loadMeta()               // 加载图片标签建议
  → loadMore()               // 加载图片列表
```

### 2. 关键词膨胀算法

**位置**: [script.js:612-680](script.js#L612-L680)

**原理**:
1. 用户输入搜索关键词 (如 "开心")
2. 递归遍历规则树，匹配组名或关键词
3. 收集所有启用的关键词 (如 "哈哈", "笑cry", "狗头")
4. 将膨胀后的关键词数组发送给后端搜索

**示例**:
```javascript
expandKeywordsToGroups(['开心'])
// 返回: {expandedKeywords: ['哈哈', '笑cry', '狗头']}
```

### 3. 层级关系管理 (拖拽)

**位置**: [script.js:2261-2350](script.js#L2261-L2350)

**逻辑**:
1. 用户拖拽组A到组B上
2. 查找组A的所有现有父节点
3. 依次删除旧的父子关系 (调用 `/api/rules/hierarchy/remove`)
4. 建立新的父子关系 (调用 `/api/rules/hierarchy/add`)
5. 刷新UI显示

**特殊情况**:
- 拖拽到根容器 (parent_id = 0): 只删除旧关系，不建立新关系
- 循环检测: 后端会拒绝形成环路的操作

### 4. 递归删除组

**位置**: [script.js:3535-3598](script.js#L3535-L3598)

**流程**:
1. 收集目标组及其所有子孙组的ID
2. 逆序遍历 (从最深的子组开始)
3. 对每个组:
   - 删除所有关键词
   - 删除作为子节点的层级关系
   - 删除作为父节点的层级关系
   - 调用后端 API 彻底删除

---

## 后端 API 接口

### 1. 获取规则树

**请求**:
```http
GET /api/rules
Headers:
  If-None-Match: <version_id>  # 可选，用于缓存验证
```

**响应**:
```json
{
  "version_id": 42,
  "groups": [
    {"group_id": 1, "group_name": "开心", "is_enabled": 1}
  ],
  "keywords": [
    {"keyword": "哈哈", "group_id": 1, "is_enabled": 1}
  ],
  "hierarchy": [
    {"parent_id": 0, "child_id": 1}  // 0 表示根节点
  ]
}
```

**304响应**: 版本未变化，客户端使用缓存

### 2. 添加组

**请求**:
```http
POST /api/rules/group/add
Content-Type: application/json

{
  "base_version": 42,      // 客户端当前版本
  "client_id": "abc123",   // 客户端唯一ID
  "group_name": "新组名",
  "is_enabled": 1
}
```

**成功响应**:
```json
{
  "success": true,
  "version_id": 43,
  "new_id": 5  // 新创建的组ID
}
```

**冲突响应 (409)**:
```json
{
  "success": false,
  "status": 409,
  "error": "conflict",
  "latest_data": { /* 最新的完整规则树数据 */ },
  "unique_modifiers": 2  // 期间有2个不同用户修改过
}
```

### 3. 添加/删除关键词

**添加**:
```http
POST /api/rules/keyword/add
{
  "base_version": 42,
  "client_id": "abc123",
  "group_id": 1,
  "keyword": "哈哈"
}
```

**删除**:
```http
POST /api/rules/keyword/remove
{
  "base_version": 42,
  "client_id": "abc123",
  "group_id": 1,
  "keyword": "哈哈"
}
```

### 4. 层级关系管理

**添加父子关系**:
```http
POST /api/rules/hierarchy/add
{
  "base_version": 42,
  "client_id": "abc123",
  "parent_id": 1,  // 0 表示设为根节点
  "child_id": 2
}
```

**删除父子关系**:
```http
POST /api/rules/hierarchy/remove
{
  "base_version": 42,
  "client_id": "abc123",
  "parent_id": 1,
  "child_id": 2
}
```

### 5. 彻底删除组

**请求**:
```http
POST /api/rules/group/delete
{
  "base_version": 42,
  "client_id": "abc123",
  "group_id": 1
}
```

---

## 乐观锁并发控制

### 核心机制

**位置**: [app.py:274-340](app.py#L274-L340)

**流程**:
1. 客户端读取规则树时获取 `version_id = 42`
2. 客户端修改后提交时携带 `base_version = 42`
3. 服务端开启**独占事务**，检查当前版本
4. 如果版本不匹配 (有人先提交了):
   - 返回 409 冲突
   - 附带最新数据和冲突统计
5. 如果版本匹配:
   - 执行写操作
   - `version_id++` (变为 43)
   - 记录日志
   - 提交事务

### 前端自动重放

**位置**: [script.js:624-710](script.js#L624-L710)

**流程**:
1. 收到 409 冲突响应
2. 静默更新本地数据为服务器最新版本
3. **预演检查**: 在新数据上模拟执行原操作
   - 如果操作仍有效 (如目标组未被删除) → 自动重试
   - 如果操作无效 → 强制刷新UI，提示用户
4. 最多重试 3 次，避免无限循环

**示例场景**:
- 用户A和用户B同时给组1添加关键词
- 用户A先提交成功 (version: 42 → 43)
- 用户B提交时检测到冲突
- 系统自动拉取最新数据，发现组1仍存在
- 自动重放用户B的添加操作 (version: 43 → 44)
- 提示: "已自动同步并保存成功！期间有 1 人修改过规则。"

---

## UI 交互细节

### 侧边栏布局

```
┌─────────────────────────────┐
│ 🌳 语义森林规则             │
├─────────────────────────────┤
│ 🔍 搜索组/关键词...         │
├─────────────────────────────┤
│ [+ 添加根组]  <- 始终可见   │
│                             │
│ 📁 开心 [+子组 +词 🗑️]     │
│   ├─ 哈哈 [×]               │
│   ├─ 笑cry [×]              │
│   └─ 狗头 [×]               │
│                             │
│ 📁 伤心 [+子组 +词 🗑️]     │
│   └─ (折叠)                 │
├─────────────────────────────┤
│ V42      [强制同步]         │
└─────────────────────────────┘
```

### 交互反馈

1. **关键词膨胀提示**
   - 搜索栏旁显示紫色徽章: `🌳 2 → 8 词`
   - Tooltip显示详情

2. **拖拽视觉反馈**
   - 拖拽源: 半透明 + 虚线边框
   - 拖拽目标: 蓝色高亮边框

3. **Toast提示**
   - 成功: 绿色背景
   - 错误: 红色背景
   - 信息: 蓝色背景

4. **加载状态**
   - 按钮变为旋转的沙漏图标
   - 禁用其他操作

---

## 常见问题

### Q1: 拖拽后组没有移动?
**原因**: 可能形成了循环引用
**解决**: 检查是否试图将父组拖到子组下

### Q2: 搜索没有膨胀关键词?
**原因**:
1. 组或关键词被禁用 (`is_enabled = 0`)
2. 规则树未正确加载

**解决**:
1. 双击组名编辑，切换"软删/恢复"状态
2. 点击"强制同步"重新加载

### Q3: 提示"保存失败:冲突次数过多"?
**原因**: 3次自动重试后仍失败
**解决**:
1. 点击"强制同步"获取最新数据
2. 重新执行操作

### Q4: 删除组后数据库仍有记录?
**说明**: 使用 `/api/rules/group/delete` 可彻底删除
**注意**: 彻底删除后无法恢复

---

## 性能优化

### 1. 缓存策略

- **LocalStorage缓存**: 规则树数据缓存在本地
- **ETag验证**: 304响应时直接使用缓存
- **标签建议缓存**: 10分钟有效期

### 2. 数据库索引

```sql
CREATE INDEX idx_keywords_group ON search_keywords(group_id);
CREATE INDEX idx_hierarchy_child ON search_hierarchy(child_id);
CREATE INDEX idx_hierarchy_parent ON search_hierarchy(parent_id);
```

### 3. 前端优化

- 事件委托减少监听器数量
- SVG图标内联避免Lucide循环调用
- 树结构渲染使用DocumentFragment批量插入

---

## 数据流图

```
用户搜索 "开心"
    ↓
expandKeywordsToGroups(['开心'])
    ↓
递归遍历规则树匹配
    ↓
返回 ['哈哈', '笑cry', '狗头']
    ↓
POST /api/search {keywords: ['哈哈', '笑cry', '狗头']}
    ↓
SQLite FTS5全文搜索
    ↓
返回匹配图片列表
    ↓
渲染到页面
```

---

## 开发调试技巧

### 1. 查看关键词膨胀过程

打开浏览器控制台，搜索时会输出:
```
[关键词膨胀] 开心 → 3 个关键词
```

### 2. 查看规则树结构

在控制台执行:
```javascript
console.log(window.app.state.rulesTree);
```

### 3. 手动触发同步

```javascript
await window.app.loadRulesTree(true);
```

### 4. 查看当前版本号

```javascript
console.log('规则版本:', window.app.state.rulesBaseVersion);
```

---

## 代码结构总览

### 前端 (script.js)

| 函数 | 行号 | 功能 |
|------|------|------|
| `buildTree()` | 403-610 | 扁平数据组装成树 |
| `expandKeywordsToGroups()` | 612-680 | 关键词膨胀算法 |
| `handleSave()` | 624-710 | 乐观锁写入 + 冲突处理 |
| `renderRulesTree()` | 1472-1850 | 渲染侧边栏UI |
| `handleHierarchyChange()` | 2261-2350 | 拖拽层级管理 |
| `deleteGroup()` | 3535-3598 | 彻底删除组 |
| `loadRulesTree()` | 2860-2930 | 加载规则树 |

### 后端 (app.py)

| 函数 | 行号 | 功能 |
|------|------|------|
| `get_rules_data()` | 107-130 | 读取规则树 |
| `try_write()` | 274-340 | 乐观锁事务 |
| `has_hierarchy_cycle()` | 193-237 | 循环检测 |
| `add_hierarchy()` | 239-270 | 添加层级关系 |

---

## 最佳实践

1. **组织结构建议**
   - 第1层: 大分类 (如"心情", "角色")
   - 第2层: 细分类 (如"开心", "伤心")
   - 第3层: 具体标签 (如"哈哈", "笑cry")

2. **关键词命名规范**
   - 使用清晰易懂的名称
   - 避免重复 (不同组可以有同名关键词)
   - 考虑用户搜索习惯

3. **并发编辑建议**
   - 避免多人同时修改同一个组
   - 遇到冲突时让系统自动处理
   - 定期点击"强制同步"确保数据最新

4. **性能考虑**
   - 单个组的关键词数量建议 < 100
   - 树的深度建议 < 5 层
   - 定期清理不需要的组

---

## 许可

本功能是 BQBQ 表情标签系统的一部分，遵循项目主许可协议。
